@code
{
    [Parameter] public required SData Data { get; set; }
    [Parameter] public required int Index { get; set; }
    [Parameter] public EventCallback<GraphNode.SData> OnMouseDown { get; set; }
    [Parameter] public EventCallback<GraphNode.SData> OnDoubleClick { get; set; }
    [Parameter] public EventCallback<GraphNode.SData> NodeStateChanged { get; set; }
}

<g class="GraphNode" tabindex="0" data-state=@Data.State
    @onmousedown=@RaiseOnMouseDown @onmousedown:stopPropagation
    @ondblclick=@RaiseOnDoubleClick @ondblclick:stopPropagation @ondblclick:preventDefault
    @onkeydown=@OnKeyDown @onkeydown:stopPropagation @onkeydown:preventDefault>
    <circle class="GraphNode-Circle" cx=@Data.X cy=@Data.Y r="25px" />
    <foreignObject class="GraphNode-HTML" width="50px" height="50px" x=@(Data.X - 25) y=@(Data.Y - 25)>
        <div class="NodeText">
            @if(Data.State is NodeState.None)
            {
                <text>@Index</text>
            }
            else if((Data.State & NodeState.Source) is not 0)
            {
                <text>S[@Index]</text>
            }
            else if((Data.State & NodeState.Destination) is not 0)
            {
                <text>D[@Index]</text>
            }
        </div>
    </foreignObject>
</g>

@code
{
    private void RaiseOnMouseDown()
    {
        OnMouseDown.InvokeAsync(Data);
    }
    private void RaiseOnDoubleClick()
    {
        OnDoubleClick.InvokeAsync(Data);
    }
    private void OnKeyDown(KeyboardEventArgs event_args)
    {
        switch(event_args.Key)
        {
            case "Delete":
            {
                Data.Dispose();
                break;
            }
            case "S" or "s":
            {
                Data.State = NodeState.Source;
                NodeStateChanged.InvokeAsync(Data);
                break;
            }
            case "D" or "d":
            {
                Data.State = NodeState.Destination;
                NodeStateChanged.InvokeAsync(Data);
                break;
            }
        }
    }

    public sealed partial class SData(double x, double y) : IDisposable
    {
        #region Instance
        public double X
        {
            get => field;
            set
            {
                field = value;
                LoopEdge?.X = value;
                foreach(NodeEdge.Point point in EdgePoints)
                {
                    point.X = value;
                }
            }
        } = x;
        public double Y
        {
            get => field;
            set
            {
                field = value;
                LoopEdge?.Y = value;
                foreach(NodeEdge.Point point in EdgePoints)
                {
                    point.Y = value;
                }
            }
        } = y;
        public NodeState State { get; set; }
        internal LoopEdge.SData? LoopEdge { get; private set; }
        internal List<NodeEdge.Point> EdgePoints { get; } = [];

        public event Action<SData>? OnDispose;

        public void AddLoopEdge()
        {
            LoopEdge = new LoopEdge.SData(X, Y);
        }
        public void RemoveLoopEdge()
        {
            LoopEdge = null;
        }
        public void AddEdgePoint(NodeEdge.Point point)
        {
            point.X = X;
            point.Y = Y;
            point.OnDispose += RemovePoint;
            EdgePoints.Add(point);

            void RemovePoint(NodeEdge.Point point)
            {
                EdgePoints.Remove(point);
                point.OnDispose -= RemovePoint;
            }
        }
        #endregion

        #region IDisposable
        public void Dispose()
        {
            foreach(NodeEdge.Point point in EdgePoints.ToArray())
            {
                point.Dispose();
            }
            RemoveLoopEdge();
            OnDispose?.Invoke(this);
        }
        #endregion
    }
    [Flags] public enum NodeState
    {
        None = 0,
        Source = 1,
        Destination = 2,
        Current = 4,
        PathPart = 8,
    }
}